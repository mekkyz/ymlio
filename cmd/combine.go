/*
Copyright Â© 2023 Mostafa Mekky <mos.mekky@gmail.com>
*/
package cmd

import (
	"fmt"
	"log"
	"os"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/spf13/cobra"
)

func readFile(fileName string) string {
	fileText, err := os.ReadFile(fileName)
	if err != nil {
		log.Fatalln(err)
	}
	return string(fileText)
}

// Option to append instead of overwrite
var extend bool

// Setting up the combine functionality
var combineCmd = &cobra.Command{
	Use:   "combine",
	Short: "Combine files (if files are not yaml, it will mark them with __RAW) into one yaml file.",
	Run: func(cmd *cobra.Command, args []string) {
		if len(args) < 3 {
			// If it's not return the message below to the user
			fmt.Println("Please provide at least 2 yaml files to combine and a file name to combine the content in.\nYou need at least 3 arguments after combine.\nFor example:\nymlio combine a.yml b.yml c.yml -> This will combine the content of a.yml and b.yml into a file c.yml")
			return
		}
		// Check that all input files exist
		for _, fileName := range args[:len(args)-1] {
			if _, err := os.Stat(fileName); err != nil {
				log.Fatalln(err)
			}
		}
		// Get the last file name passed in which the files will be combined
		lastArgsFileName := args[len(args)-1]
		// Check if extend is on and turn append on if --extend
		var openFlags int
		if extend {
			openFlags = os.O_CREATE | os.O_WRONLY | os.O_APPEND
		} else {
			openFlags = os.O_CREATE | os.O_WRONLY | os.O_TRUNC
		}
		// Open the last file passed in the command line for saving the combined file
		file, err := os.OpenFile(lastArgsFileName, openFlags, 0644)
		if err != nil {
			log.Fatalln(err)
		}
		defer file.Close()
		// Add a comment at the top of the file
		if _, err := file.WriteString("# This file is generated by ymlio v0.1\n# Do not edit manually."); err != nil {
			log.Fatalf("failed to write comment: %v", err)
		}
		// Create a map to hold all the YAML documents
		allDocs := make(map[string]interface{})
		// Iterate through all the filenames that we want to combine
		for i, fileName := range args[:len(args)-1] {

			// Checking if the file ends with .yml or .yaml
			if strings.Contains(fileName, ".yml") && strings.HasSuffix(fileName, ".yml") || strings.Contains(fileName, ".yaml") && strings.HasSuffix(fileName, ".yaml") {
				// Handle the anchors first
				fileNameAnchor, err := handleAnchor(fileName)
				if err != nil {
					log.Fatalln(err)
				}
				// Read the file content after handling the anchors
				fileText := readFile(fileNameAnchor)
				// Parse the file content into a map[string]interface{}
				var doc map[string]interface{}
				if err := yaml.Unmarshal([]byte(fileText), &doc); err != nil {
					log.Fatalf("failed to parse %q: %v", fileName, err)
				}
				// Add the document to the allDocs map with the file name as the key
				allDocs[fileName] = doc
			} else {
				// If the filename isn't a yaml file, in this case it's a text file, read the content
				fileText := readFile(fileName)
				// Add the content as a string to the allDocs map with the file name as the key, marked as "RAW"
				allDocs[fileName] = map[string]string{"__RAW": strings.TrimSpace(fileText)}
			}
			// Add a newline separator between files, except for the last file
			if i < len(args)-2 {
				if _, err := file.WriteString("\n"); err != nil {
					log.Fatalf("failed to write separator: %v", err)
				}
			}
		}
		// Write the combined YAML documents to the output file
		encoder := yaml.NewEncoder(file)
		encoder.SetIndent(2)
		if err := encoder.Encode(allDocs); err != nil {
			log.Fatalf("failed to encode YAML: %v", err)
		}
	},
}

func init() {
	rootCmd.AddCommand(combineCmd)
	// Add the --only flag to the split command
	combineCmd.Flags().BoolVarP(&extend, "extend", "e", false, "Append data when combining instead of overwriting")
	// splitYmlCmd.PersistentFlags().String("only", "", "Specify some YAML file to extract")
}
